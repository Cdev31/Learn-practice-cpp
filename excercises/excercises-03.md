# üß© C++ ‚Äì 60 Ejercicios (Solo Enunciados)
### Intermedio (20) ‚Ä¢ Avanzado (20) ‚Ä¢ Competitivo (20)
**Nuevos, distintos a todos los anteriores.**

---

# üü¶ 20 Ejercicios ‚Äì Nivel Intermedio

1. Pide un n√∫mero y determina si es positivo, negativo o neutro.
2. Lee dos cadenas e indica cu√°l es lexicogr√°ficamente mayor.
3. Dado un n√∫mero `n`, imprime todos los m√∫ltiplos de 4 menores o iguales a `n`.
4. Escribe un programa que cuente cu√°ntas letras may√∫sculas contiene una frase.
5. Dado un arreglo de 10 n√∫meros, calcula la media arm√≥nica.
6. Pide un n√∫mero y muestra su representaci√≥n en binario (manual, sin bitset).
7. Determina si un a√±o es bisiesto usando solo operadores l√≥gicos.
8. Pide 15 n√∫meros y encuentra el segundo mayor sin ordenar el vector.
9. Implementa un programa que reciba una palabra y elimine sus consonantes.
10. Lee n√∫meros hasta que el usuario ingrese un negativo; calcula la suma de los pares.
11. Pide una cadena y cuenta cu√°ntas veces aparece cada vocal.
12. Genera una lista de 20 n√∫meros aleatorios y calcula cu√°ntos son divisibles entre 6.
13. Dada una frase, reemplaza cualquier d√≠gito por el car√°cter `#`.
14. Convierte todas las vocales de una frase a su versi√≥n acentuada (a‚Üí√°, e‚Üí√©‚Ä¶).
15. Pide una cadena e invierte el orden de sus palabras.
16. Dado un n√∫mero entero, determina si tiene un n√∫mero par de d√≠gitos.
17. Pide dos vectores de 5 enteros cada uno y genera un tercer vector con sus sumas √≠ndice a √≠ndice.
18. Simula una ruleta: genera un n√∫mero entre 0‚Äì36 e indica si es rojo, negro o verde.
19. Convierte una frase a formato ‚Äúalternado‚Äù: may√∫scula/min√∫scula alternada.
20. Dado un n√∫mero `n`, imprime los primeros `n` t√©rminos de la serie de Fibonacci.

---

# üü© 20 Ejercicios ‚Äì Nivel Avanzado

21. Implementa una cola prioritaria manualmente usando un vector.
22. Escribe una funci√≥n que divida una cadena en tokens usando un delimitador variable.
23. Implementa una versi√≥n b√°sica de min‚Äìheap sin `priority_queue`.
24. Dado un vector de enteros, construye otro con las diferencias absolutas entre elementos consecutivos.
25. Simula un sistema de reservas con estructuras: ID, nombre y fecha.
26. Implementa un algoritmo que determine si una lista de intervalos puede unirse sin huecos.
27. Crea una funci√≥n que aplane una matriz 2D en un vector 1D.
28. Implementa una matriz esparcida (sparse matrix) usando `vector<tuple<int,int,double>>`.
29. Haz una funci√≥n que eval√∫e si un n√∫mero es ‚Äúcasi primo‚Äù (1 divisor extra adicional).
30. Construye un generador de n√∫meros pseudoaleatorios lineal congruente (LCG).
31. Implementa un registro de empleados con b√∫squeda por ID usando b√∫squeda binaria.
32. Crea un sistema de logs en archivo con nivel de severidad y timestamp.
33. Implementa un programa que encuentre la subcadena m√°s larga sin caracteres repetidos.
34. Construye un algoritmo que determine si un vector puede ser dividido en dos partes con suma igual.
35. Implementa un historial de operaciones usando una pila.
36. Dise√±a un rotador de matrices 180¬∞ sin usar matrices auxiliares.
37. Implementa un lector de CSV simple (sin librer√≠as externas).
38. Construye una tabla hash simple usando ‚Äúlinear probing‚Äù.
39. Simula un servidor de impresi√≥n que maneja trabajos en cola con prioridad.
40. Dado un vector de puntos 2D, encuentra el m√°s cercano al origen.

---

# üü• 20 Ejercicios ‚Äì Nivel Competitivo / Aplicado

41. Implementa el algoritmo de Kruskal para obtener el √°rbol de expansi√≥n m√≠nima.
42. Implementa el algoritmo de Bellman‚ÄìFord para caminos m√≠nimos con pesos negativos.
43. Dada una cadena, encuentra el pal√≠ndromo m√°s largo que contiene.
44. Calcula el n√∫mero de maneras de escribir un n√∫mero `n` como suma de enteros positivos (DP).
45. Dado un arreglo, encuentra la subsecuencia creciente continua m√°s larga.
46. Implementa el algoritmo de convex hull (Graham Scan).
47. Construye un sistema que detecte puentes (edges cr√≠ticos) en un grafo.
48. Implementa el algoritmo de b√∫squeda A* en una cuadr√≠cula.
49. Implementa una simulaci√≥n de colisiones 1D entre part√≠culas con masas y velocidades.
50. Dado un grafo, determina si es bipartito.
51. Calcula la matriz de adyacencia elev√°ndola a potencia `k` (multiplicaci√≥n repetida).
52. Implementa el algoritmo de backtracking para generar todas las combinaciones de tama√±o `k`.
53. Resuelve el problema de ‚ÄúJob Scheduling‚Äù con ganancias m√°ximas.
54. Implementa un solver para N-Reinas usando backtracking.
55. Dado un arreglo, encuentra el subarreglo m√°s largo con suma igual a cero.
56. Calcula el n√∫mero de caminos √∫nicos en un grafo DAG usando DP.
57. Implementa b√∫squeda ternaria para minimizar una funci√≥n unimodal.
58. Genera todas las particiones posibles de un conjunto de `n` elementos.
59. Implementa detecci√≥n de ciclos en grafo no dirigido con Union‚ÄìFind.
60. Dado un puzzle 8-puzzle, implementa un solver por b√∫squeda A* con heur√≠stica Manhattan.

---
