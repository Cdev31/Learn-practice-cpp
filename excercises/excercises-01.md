# üß© C++ ‚Äì 60 Ejercicios SOLO ENUNCIADOS  
**NIVEL: Intermedio (1‚Äì20), Avanzado (21‚Äì40), Competitivo / Aplicado (41‚Äì60)**  


# üü¶ **20 Ejercicios ‚Äì Nivel Intermedio**

1. Escribe un programa que determine si un n√∫mero es par, impar o cero (usa `if` y operadores l√≥gicos).
2. Dado un arreglo de 10 enteros, encuentra el mayor y el menor sin usar `<algorithm>`.
3. Lee una cadena y cuenta cu√°ntas vocales contiene (may√∫sculas y min√∫sculas).
4. Implementa un men√∫ interactivo que permita sumar, restar, multiplicar o dividir dos n√∫meros.
5. Dado un n√∫mero `n`, imprime la tabla de multiplicar del 1 al 12.
6. Escribe un programa que lea nombres hasta que el usuario escriba `"fin"` y luego imprima cu√°ntos nombres se ingresaron.
7. Dado un entero `n`, imprime todos los n√∫meros primos menores o iguales a `n`.
8. Escribe una funci√≥n que reciba un n√∫mero y devuelva cu√°ntos d√≠gitos tiene.
9. Implementa un contador de palabras usando `getline` y analizando espacios.
10. Escribe un programa que simule un login con m√°ximo 3 intentos.
11. Dado un vector de enteros, cuenta cu√°ntas veces aparece un n√∫mero pedido por el usuario.
12. Implementa un programa que convierta grados Celsius a Fahrenheit y viceversa.
13. Lee las notas de un alumno y calcula el promedio, indicando si aprob√≥ o reprob√≥.
14. Almacena 10 cadenas y ord√©nalas alfab√©ticamente usando `sort`.
15. Genera 20 n√∫meros aleatorios entre 1 y 100 y muestra cu√°ntos son pares.
16. Escribe una funci√≥n que determine si una cadena es un pal√≠ndromo.
17. Simula un cajero b√°sico: depositar, retirar, consultar saldo.
18. Implementa un programa que elimine todos los espacios repetidos en una cadena.
19. Convierte una frase a min√∫sculas sin usar funciones prehechas (hazlo car√°cter por car√°cter).
20. Pide 5 n√∫meros y calcula su varianza y desviaci√≥n est√°ndar.

---

# üü© **20 Ejercicios ‚Äì Nivel Avanzado**

21. Implementa una calculadora de polinomios representados como `vector<double>`.
22. Dise√±a un programa que eval√∫e expresiones como `"12 + 3 * 5 - 8"`, respetando precedencia.
23. Implementa la b√∫squeda binaria manual (sin `<algorithm>`) con manejo de errores.
24. Crea una funci√≥n que tome un vector y elimine duplicados manteniendo el orden original.
25. Implementa una cola usando dos pilas (`stack`).
26. Implementa una pila usando dos colas (`queue`).
27. Simula un sistema de inventario usando `struct`, `vector` y funciones separadas.
28. Escribe un analizador que cuente cu√°ntas veces aparece cada palabra en un texto.
29. Dado un vector de enteros, encuentra la subsecuencia creciente m√°s larga (no necesariamente continua).
30. Simula el movimiento de una part√≠cula en 2D usando `struct` y actualizaci√≥n por pasos.
31. Implementa un mini-sistema de archivos donde cada ‚Äúarchivo‚Äù tiene nombre, tama√±o y extensi√≥n.
32. Genera 1000 n√∫meros aleatorios y calcula la media recursiva sin usar acumuladores tradicionales.
33. Crea una matriz `NxN`, ll√©nala y rota la matriz 90¬∞ (sin crear otra matriz).
34. Implementa un programa que lea un archivo `.txt` y cuente l√≠neas, palabras y caracteres.
35. Simula una base de datos simple usando un `vector` de `struct` con CRUD completo.
36. Implementa una funci√≥n que convierta n√∫meros romanos a decimales.
37. Implementa una funci√≥n que convierta n√∫meros decimales a romanos.
38. Escribe un algoritmo que valide una expresi√≥n de par√©ntesis, llaves y corchetes balanceados.
39. Implementa b√∫squeda de patrones en cadenas usando la t√©cnica de ventana deslizante.
40. Crea una funci√≥n que reciba un vector y determine si se puede ordenar con m√°ximo un swap.

---

# üü• **20 Ejercicios ‚Äì Nivel Competitivo / Aplicado**

41. Dado un arreglo con n√∫meros positivos y negativos, encuentra la sublista con suma m√°xima (Kadane manual).
42. Implementa el algoritmo de Dijkstra sin librer√≠as externas (usando `vector` y `priority_queue`).
43. Dado un vector, encuentra el primer elemento que no se repite.
44. Calcula el n√∫mero de inversiones en un arreglo usando merge sort modificado.
45. Implementa el algoritmo de ‚ÄúTwo Pointers‚Äù para encontrar dos valores cuya suma sea un n√∫mero objetivo.
46. Implementa BFS y DFS sobre un grafo representado con listas de adyacencia.
47. Resuelve el problema de la mochila 0/1 usando programaci√≥n din√°mica.
48. Escribe una funci√≥n que determine cu√°ntas veces aparece un patr√≥n dentro de un texto usando KMP.
49. Genera todas las permutaciones posibles de una cadena.
50. Implementa el algoritmo de ordenamiento quicksort manualmente.
51. Resuelve el cl√°sico problema de las torres de Hanoi mostrando cada movimiento.
52. Implementa un sistema para detectar ciclos en grafos dirigidos.
53. Dado un mapa NxM con obst√°culos, encuentra el camino m√°s corto usando BFS.
54. Genera n√∫meros primos hasta 10 millones usando la Criba de Erat√≥stenes optimizada.
55. Resuelve el problema de "interval scheduling": escoger la mayor cantidad de intervalos no solapados.
56. Implementa un √°rbol binario de b√∫squeda con inserci√≥n, b√∫squeda y eliminaci√≥n.
57. Implementa un trie para almacenar cadenas y permitir b√∫squedas por prefijo.
58. Dado un vector, encuentra el ‚Äúelemento mayoritario‚Äù (mayor a n/2) usando Boyer-Moore.
59. Dados `n` pares de par√©ntesis, genera todas las combinaciones v√°lidas.
60. Simula un motor de colisi√≥n de part√≠culas: cada part√≠cula tiene posici√≥n, velocidad y actualizaci√≥n por tiempo.

