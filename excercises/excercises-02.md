# üß© C++ ‚Äì 60 Ejercicios (Solo Enunciados)
## Intermedio (20) ‚Ä¢ Avanzado (20) ‚Ä¢ Competitivo (20)
**Todos distintos a los anteriores y cubren:**  
condicionales, bucles, tipos de datos, funciones, strings, librer√≠as, manejo de errores, modularizaci√≥n, operadores.

---

# üü¶ 20 Ejercicios ‚Äì Nivel Intermedio

1. Pide un n√∫mero entero y determina si es m√∫ltiplo de 3, 5 o ambos.
2. Lee una cadena y reemplaza todas las vocales por el car√°cter `*`.
3. Pide una hora en formato 24h y convierte a formato 12h con AM/PM.
4. Dado un n√∫mero `n`, imprime los n√∫meros del 1 al `n` pero omite los que terminen en 7.
5. Calcula la suma de todos los enteros entre dos n√∫meros proporcionados por el usuario.
6. Pide 10 n√∫meros y muestra cu√°ntos son mayores que el promedio.
7. Lee una frase y muestra cu√°ntas palabras tienen m√°s de 5 letras.
8. Construye una funci√≥n que convierta una cadena en "T√≠tulo": cada palabra inicia con may√∫scula.
9. Escribe un programa que calcule el factorial de un n√∫mero usando un bucle `for`.
10. Pide un n√∫mero y muestra sus divisores positivos.
11. Implementa un programa que invierta un vector de enteros sin usar `reverse()`.
12. Lee una fecha (d√≠a, mes, a√±o) y determina si es v√°lida.
13. Pide dos cadenas y determina si una es subcadena de la otra.
14. Calcula la suma de los d√≠gitos de un n√∫mero entero.
15. Simula tirar dos dados 20 veces y muestra cu√°ntas veces sale cada suma posible.
16. Convierte una cadena a ‚Äúsnake_case‚Äù manualmente.
17. Pide precios en `double` hasta que el usuario escriba `0`; luego muestra total y promedio.
18. Cuenta cu√°ntos caracteres num√©ricos, alfab√©ticos y especiales tiene una cadena.
19. Genera un vector de 15 n√∫meros aleatorios y ord√©nalos sin usar `sort()`.
20. Determina si un n√∫mero es perfecto (la suma de sus divisores propios = n√∫mero).

---

# üü© 20 Ejercicios ‚Äì Nivel Avanzado

21. Implementa una funci√≥n que devuelva la mediana de un vector de `double`.
22. Dado un vector, rota sus elementos `k` posiciones hacia la derecha.
23. Implementa una lista enlazada simple desde cero con inserci√≥n, b√∫squeda y eliminaci√≥n.
24. Crea una funci√≥n que elimine todos los elementos repetidos en un vector *sin perder orden*.
25. Simula una calculadora cient√≠fica que soporte seno, coseno, logaritmo y ra√≠z cuadrada.
26. Implementa b√∫squeda ternaria en un rango num√©rico.
27. Construye una matriz `NxM` y calcula su transpuesta sin usar matrices auxiliares extra.
28. Escribe un validador de contrase√±as (m√≠nimo 8 chars, may√∫scula, min√∫scula, n√∫mero, s√≠mbolo).
29. Implementa una cola circular con un arreglo fijo.
30. Simula un sistema de pedidos donde cada pedido tiene ID, fecha y monto.
31. Implementa multiplicaci√≥n de matrices cuadradas.
32. Crea una funci√≥n que determine si dos cadenas son anagramas sin usar `sort`.
33. Implementa un autoguardado: guarda en archivo un vector de estructuras cada cierto tiempo.
34. Implementa un sistema de log con niveles (‚ÄúINFO‚Äù, ‚ÄúWARN‚Äù, ‚ÄúERROR‚Äù) usando `enum class`.
35. Crea una funci√≥n que verifique si un vector est√° casi ordenado (m√°x 1 inversi√≥n).
36. Implementa un algoritmo que identifique pal√≠ndromos num√©ricos (como 12321).
37. Haz un parser simple de comandos estilo terminal (`mkdir`, `cd`, `ls`).
38. Implementa un minijuego de turnos con ataque, defensa y puntos de vida usando structs.
39. Crea una funci√≥n que convierta una expresi√≥n como `"10/2+3*4"` en notaci√≥n postfija.
40. Implementa un sistema de horarios que detecte si dos intervalos se solapan.

---

# üü• 20 Ejercicios ‚Äì Nivel Competitivo / Aplicado

41. Dado un vector de enteros, encuentra la subsecuencia contigua con suma m√≠nima.
42. Implementa el algoritmo de Prim para hallar el MST de un grafo.
43. Calcula la subsecuencia creciente m√°s larga utilizando DP (LIS cl√°sico).
44. Implementa Union‚ÄìFind con compresi√≥n de caminos.
45. Dados `n` intervalos, encuentra cu√°ntos puntos m√≠nimos se necesitan para cubrirlos.
46. Encuentra el primer √≠ndice donde un arreglo pasa de no ordenado a ordenado.
47. Implementa un algoritmo para encontrar los k elementos m√°s frecuentes de un arreglo.
48. Resuelve el problema del "viajero cansado": dado un vector, encuentra la ruta de menor costo local.
49. Implementa el algoritmo de Rabin‚ÄìKarp para b√∫squeda de cadenas.
50. Encuentra el n√∫mero m√°s cercano a un valor objetivo dentro de un BST.
51. Simula un sistema de colas con prioridad en un hospital.
52. Determina si es posible transformar una cadena en otra mediante swaps adyacentes m√≠nimos.
53. Resuelve el problema de ‚Äúgas stations‚Äù: determinar si puedes completar el circuito.
54. Implementa multiplicaci√≥n r√°pida por exponenciaci√≥n binaria.
55. Calcula la cantidad de caminos posibles en una cuadr√≠cula usando DP.
56. Implementa un heap binario manual e inserta N elementos en √©l.
57. Dado un grafo, determina si existe un camino Hamiltoniano.
58. Calcula el √°rea de la uni√≥n de varios rect√°ngulos en un plano.
59. Encuentra el tama√±o del componente conectado m√°s grande en una matriz de 0s y 1s.
60. Implementa un solver de sudoku b√°sico por backtracking.

